function [SOL,vm] = autofind_2step(vm,list,list_core,response_halo,varargin)
% find beta0 with dynamical theta0 and W0
try
	% set nlinfit options
	opts = statset('nlinfit');
	% opts.Display = 'iter';
	% opts.MaxIter = 100;

	% set logging function
	fLog = @(model,SOL,list) fprintf('<strong>%1.15e</strong>\t%1.15e\t%1.15e\t%1.3e\n',SOL.data.beta0,SOL.data.theta0,SOL.data.W0,list.chi2(SOL));

	% set model wrapper (nlinfit vector => model)
	fModel = @(b,SOL) struct(...
		'param', struct(...
			'm',		vm.param.m,...
			'beta0',	b(1),...
			'theta0',	vm.param.theta0,...
			'W0',		vm.param.W0 ...
		),...
		'options',	vm.options ...
	);

	% set arguments
	arg = lib.struct.merge(struct(...
		'model',			vm,...
		'fModel',			fModel,...
		'fSolution',		@(vm) find_core(vm,list_core,response_halo), ...
		'list',				list,...
		'debug',			fLog,...
		'opts',				opts ...
	),struct(varargin{:}));

	% find solution (beta0,theta0,W0) for given particle mass
	fprintf('%21s\t%21s\t%21s\t%9s\n','beta0','theta0','W0','chi2')
	SOL = model.tov.rar.autofind.beta0(arg);
catch
	SOL = script.bisect_beta0(vm,response_halo,...
		'fSolution', @(vm) find_core(vm,list_core,response_halo));
end

% update model
vm.param.beta0	= SOL.data.beta0;
vm.param.theta0 = SOL.data.theta0;
vm.param.W0		= SOL.data.W0;

function SOL = find_core(vm,list_core,response_halo)
% find core (theta0) for given beta0 and W0
fprintf(' === 1/2 === find core\n')
[~, vm] = script.autofind_core(vm,list_core);

% then find halo (W0) for given beta0 and theta0
fprintf(' === 2/2 === find halo\n')
SOL = script.bisect_W0(vm,response_halo);