function varargout = gosect_2step(vm,list,list_core,response_halo,varargin)

S.fY		= @(SOL) list.chi2(SOL);
S.fSolution = @(vm) find_core(vm,list_core,response_halo);
S.fVector	= @(vm) vm.param.beta0;

S.fModel = @(SOL) struct(...
	'param', struct(...
		'm',		SOL.data.m,...
		'beta0',	SOL.data.beta0,...
		'theta0',	SOL.data.theta0,...
		'W0',		SOL.data.W0 ...
	),...
	'options', vm.options ...
);

S.fUpdate = @(x,vm) struct(...
	'param', struct(...
		'm',		vm.param.m,...
		'beta0',	x,...
		'theta0',	vm.param.theta0,...
		'W0',		vm.param.W0 ...
	),...
	'options', vm.options ...
);

S.options = struct(...
	'tol',		1E-5,...
	'MaxIter',	20 ...
);

S.fLog = @(SOL) fprintf('<strong>%1.15e</strong>\t%1.15e\t%1.15e\t%1.3e\n',SOL.data.beta0,SOL.data.theta0,SOL.data.W0,list.chi2(SOL));

vm1 = S.fUpdate(vm.param.beta0*(1 - 10E-2),vm);
vm2 = S.fUpdate(vm.param.beta0*(1 + 10E-2),vm);

[varargout{1:nargout}] = lib.fitting.gosect(vm1,vm2,S);



function [SOL,vm] = find_core(vm,list_core,response_halo)
% find core (theta0) for given beta0 and W0
fprintf(' === 1/2 === find core\n')
try
	[~, vm] = script.nlinfit_core(vm,list_core);
catch
	[~, vm] = script.bisect_theta0(vm,list_core.data{1});
end

% then find halo (W0) for given beta0 and theta0
fprintf(' === 2/2 === find halo\n')
[SOL,vm] = script.bisect_W0(vm,response_halo);